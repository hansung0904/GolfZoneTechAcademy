<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="main.js"></script>
</head>
<script>
    /*  typeof() method = return 타입을 알려준다.
        자바 스크립트는 function 타입이 제일 최상위에 있다
        (java는 object가 제일 최상)
        boolean 리턴타입 나올때 "" 안에 공백이든 어떤게 들어있기만 하면 무조건 true 반환
        ""에 정말 아무것도 없어야 false 반환
        js에서 = 오른쪽은 literal~
        a = 10; 이런식으로 써주어도 되나 조심해야 할 상황이 온다
        항상 var , let 이런식으로 정해주고 변수에 값을 할당하는 습관을 들이자.

        **왜 var 보단 let을 사용해야하는지**
        --java 처럼 동일한 이름의 변수명을 사용할 수 없기 때문에 
        협업을 하는 과정에서 변수가 어떤 역할을 하는지 정확하게 파악 할 수 있다.
        
        js도 변수명을 항상 camelCase로 작성하는 습관을 들이자
        method 안에 할당연산 = 이 있으면 무조건 ;으로 닫아줘야한다
        하지만 method 안에 할당연산이 없으면 ;으로 안닫아줘도
        콘솔에 찍히는데에는 문제가 없다.        



    
    */
    window.onload = function () {
        console.log("onload...") // body가 다 읽히고 나온다음에 onload...해라
    };

    var a = 10; // var 변수의 특징은 변수를 중복으로 선언해도 상관없다 난 이래서 js가 밉다
    console.log(console.log(a));
    console.log(typeof (a));
    console.log("==============================");

    var a = "kim"; // singlequotation 도 String이고 doublequotation도 String이다..
    a = "aaaaa";
    console.log(a);
    console.log(typeof (a));
    console.log("==============================");

    var a = 3.14;
    console.log(a);
    console.log(typeof (a));
    console.log("==============================");

    var b; // undefined 되어서 나옴 왜? 값을 할당하지 않았기 때문 variable을 a로주면 위에 값 읽어와서 undefined 되지 않음.
    console.log(b);
    console.log(typeof (b));
    console.log("==============================");

    var obj = null;
    console.log(obj);
    console.log(typeof (obj));
    console.log("==============================");

    var arr = []; // js에서 []는 array 배열도 타입으로 따지면 주소가 할당되기 때문에 object로 나옴.
    console.log(arr);
    console.log(typeof (arr));
    console.log("==============================");

    var vo = {}; // {} 는 그냥 object 형식에 object 타입으로 나온다.
    console.log(vo);
    console.log(typeof (vo));
    console.log("==============================");

    var fn = function () { }; // function 타입으로 반환
    console.log(fn);
    console.log(typeof (fn));
    console.log("==============================");

    var bool = true;
    console.log(bool);
    console.log(typeof (bool));
    console.log("==============================");

    var x = "abc";
    var y = "def"
    console.log(x + y);

    console.log("==============================");
    // JS도 type casting을 해주어야한다.
    console.log(String(bool));
    console.log(typeof (String(bool)));
    console.log(typeof (String(333))); // 숫자 333인데 String으로 반환
    console.log("==============================");

    console.log(typeof (Number("123"))); // "123"은 String인데 넘버로 리턴해줌.
    console.log(typeof (Number(true))); // true도 넘버가 되어버린다.
    console.log((Number("abc"))); // NaN 으로 리턴해준다.
    console.log(typeof (Number("abc"))); // NaN을 캐스팅해서 number로 나온다.
    console.log("==============================");

    console.log(Boolean("abc")); // String일때 ""안에 한글자라도 들어가 있으면 무조건 true로 반환해줌
    console.log(Boolean("")); // false로 반환
    console.log(Boolean({})); // true로 반환
    console.log(Boolean(null)); // null 도 false
    console.log(Boolean(0)); // null 도 false
    console.log("==============================");

    console.log(Boolean(undefined)); // false 반환
    console.log(Boolean(NaN)); // false 반환
    console.log("=============================="); // 결론 java에서는 true false만 넣어주어야하는데 0 이런식으로 대입해도 된다~


</script>

<body>
    <h1>index page</h1>
</body>

</html>